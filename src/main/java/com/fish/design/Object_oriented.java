package com.fish.design;

/**
 * 面向对象设计原则
 */
public class Object_oriented {
    /*
     * 职责单一原则
     * 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，
     * 或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。
     * 单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，
     * 需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验
     *
     * 开闭原则
     * 一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。
     * 为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。
     * 注意：因为xml和properties等格式的配置文件是纯文本文件，可以直接通过VI编辑器或记事本进行编辑，
     * 且无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。
     * 如果一个系统在扩展时只涉及到修改配置文件，而原有的Java代码或C#代码没有做任何修改，该系统即可认为是一个符合开闭原则的系统。
     *
     * 里氏代换原则
     * 如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，
     * 程序P的行为没有变化，那么类型S是类型T的子类型。
     * 所有引用基类（父类）的地方必须能透明地使用其子类的对象。
     * 里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，
     * 因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。
     * 在使用里氏代换原则时需要注意如下几个问题：
     * (1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，
     * 在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。
     * (2) 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，
     * 并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，
     * 同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。
     * (3) Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，
     * 这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。
     *
     * 依赖倒转原则
     * 抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。
     * 依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，
     * 即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，
     * 而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，
     * 而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。
     *
     * 接口隔离原则
     * 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。
     * 根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。
     * 每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。
     * 这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，
     * 仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。
     * 对于这两种不同的含义，ISP的表达方式以及含义都有所不同：
     * (1) 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，
     * 接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，
     * 此时，这个原则可以叫做“角色隔离原则”。
     * (2) 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，
     * 客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。
     * 在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，
     * 为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，
     * 并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，
     * 每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，
     * 即为不同的客户端提供宽窄不同的接口。
     * 在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，
     * 不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。
     * 一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。
     *
     * 合成复用原则
     * 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；
     * 新对象通过委派调用已有对象的方法达到复用功能的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。
     *
     * 迪米特法则
     * 一个软件实体应当尽可能少地与其他实体发生相互作用。
     *
     *
     *
     *
     *
     *
     *
     */
    public static void main(String[] args) {

    }
}
